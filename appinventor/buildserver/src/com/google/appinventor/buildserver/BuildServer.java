package com.google.appinventor.buildserver;

import com.google.common.collect.ImmutableMap;
import com.google.common.io.ByteStreams;
import com.google.common.io.Files;

import com.sun.grizzly.http.SelectorThread;
import com.sun.jersey.api.container.grizzly.GrizzlyServerFactory;

import org.codehaus.jettison.json.JSONException;
import org.codehaus.jettison.json.JSONObject;
import org.kohsuke.args4j.Option;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.net.URL;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

/**
 * Top level class for exposing the building of App Inventor APK files as a RESTful web service.
 *
 * Note that these BuildServer objects are created per request
 *
 * @author markf@google.com (Mark Friedman)
 */
// The Java class will be hosted at the URI path "/buildserver"
@Path("/buildserver")
public class BuildServer {

  static class CommandLineOptions {
    @Option(name = "--childProcessRamMb",
            usage = "Maximum ram that can be used by a child processes, in MB.")
    int childProcessRamMb = 2048;
  }

  private static CommandLineOptions commandLineOptions = new CommandLineOptions();

  private static final MediaType APK_MEDIA_TYPE =
      new MediaType("application", "vnd.android.package-archive",
                    ImmutableMap.of("charset", "utf-8"));

  private static final MediaType ZIP_MEDIA_TYPE =
      new MediaType("application", "zip", ImmutableMap.of("charset", "utf-8"));

  // The built APK file for this build request, if any.
  private File outputApk;

  // The temp directory that we're building in.
  private File outputDir;

  // The android.keystore file generated by this build request, if necessary.
  private File outputKeystore;

  // The zip file where we put all the build results for this request.
  private File outputZip;

  /**
   * Build an APK file from the input zip file. The zip file needs to be a variant of the same
   * App Inventor source zip that's generated by the Download Source command.  The differences are
   * that it might not contain a .yail file (in which case we will generate the YAIL code) and it
   * might contain an android.keystore file at the top level (in which case we will use it to sign
   * the APK.  If there is no android.keystore file in the zip we will generate one.
   *
   * @param userName  The user name to be used in making the CN entry in the generated keystore
   * @param zipFile
   * @return the APK file
   */
  @POST
  @Path("build-from-zip")
  @Produces("application/vnd.android.package-archive;charset=utf-8")
  public Response buildFromZipFile(@QueryParam("uname") String userName, File zipFile)
      throws IOException {
    build(userName, zipFile);
    // Note that if we decide we don't need a content-disposition header then we can change this
    // method to just return File and then just return outputApk without building a Response object
    // explicitly.
    Response response = Response.ok(outputApk)
        .header("Content-Disposition", "attachment; filename=\"" + outputApk.getName() + "\"")
        .build();
    outputApk.deleteOnExit();  // Just in case
    return response;
  }

  /**
   * Build an APK file from the input zip file. The zip file needs to be a variant of the same
   * App Inventor source zip that's generated by the Download Source command.  The differences are
   * that it might not contain a .yail file (in which case we will generate the YAIL code) and it
   * might contain an android.keystore file at the top level (in which case we will use it to sign
   * the APK.  If there is no android.keystore file in the zip we will generate one and return it
   * in along with the APK file.
   *
   * We'll respond to the requestor with a zip file containing the build.out and build.err files as
   * well as the APK file if the build succeedeed and the android.keystore file if it was not
   * provided in the input zip
   *
   * @param userName  The user name to be used in making the CN entry in the generated keystore
   * @param inputZipFile  The zip file representing the App Inventor source code.
   * @return an "OK" {@link Response}.
   */
  @POST
  @Path("build-all-from-zip")
  @Produces("application/zip;charset=utf-8")
  public Response buildAllFromZipFile(@QueryParam("uname") String userName, File inputZipFile)
      throws IOException, JSONException {
    try {
      buildAndCreateZip(userName, inputZipFile);
      // Note that if we decide we don't need a content-disposition header then we can change this
      // method to just return File and then just return outputZip without building a Response
      // object explicitly.
      return Response.ok(outputZip)
          .header("Content-Disposition", "attachment; filename=\"" + outputZip.getName() + "\"")
          .build();
    } finally {
      cleanUp();
    }
  }

  /**
   * Asynchronously build an APK file from the input zip file and then send it to the callbackUrl.
   * The input zip file needs to be a variant of the same App Inventor source zip that's generated
   * by the Download Source command.  The differences are that it might not contain a .yail file (in
   * which case we will generate the YAIL code) and it might contain an android.keystore file at the
   * top level (in which case we will use it to sign the APK).
   *
   * We'll use the callbackUrlStr to post back a zip file containing the build.out and build.err
   * files as well as the APK file if the build succeedeed and the android.keystore file if it was
   * not provided in the input zip
   *
   * @param userName  The user name to be used in making the CN entry in the generated keystore.
   * @param callbackUrlStr An url to send the build results back to.
   * @param inputZipFile  The zip file representing the App Inventor source code.
   * @return an "OK" {@link Response}.
   */
  @POST
  @Path("build-all-from-zip-async")
  public Response buildAllFromZipFileAsync(@QueryParam("uname") final String userName,
                                           @QueryParam("callback") final String callbackUrlStr,
                                           final File inputZipFile)
      throws IOException {
    Thread buildThread = new Thread(new Runnable() {
      @Override
      public void run() {
        try {
          buildAndCreateZip(userName, inputZipFile);
          // Send zip back to the callbackUrl
          URL callbackUrl = new URL(callbackUrlStr);
          HttpURLConnection connection = (HttpURLConnection) callbackUrl.openConnection();
          connection.setDoOutput(true);
          connection.setRequestMethod("POST");
          // Make sure we aren't misinterprested as form-url-encoded
          connection.addRequestProperty("Content-Type", "application/zip; charset=utf-8");
          connection.setConnectTimeout(60000);
          connection.setReadTimeout(60000);
          BufferedOutputStream bufferedOutputStream =
              new BufferedOutputStream(connection.getOutputStream());
          ByteStreams.copy(new FileInputStream(outputZip), bufferedOutputStream);
          bufferedOutputStream.flush();
          bufferedOutputStream.close();

          if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
            // TODO(user) Maybe do some retries
          }

        } catch (Exception e) {
          // TODO(user): Maybe send a failure callback
        } finally {
          cleanUp();
        }
      }
    });
    buildThread.start();

    return Response.ok().build();
  }

  private void buildAndCreateZip(String userName, File inputZipFile)
      throws IOException, JSONException {
    Result buildResult = build(userName, inputZipFile);
    boolean buildSucceeded = buildResult.succeeded();
    outputZip = File.createTempFile(inputZipFile.getName(), ".zip");
    ZipOutputStream zipOutputStream =
        new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(outputZip)));
    if (buildSucceeded) {
      if (outputKeystore != null) {
        zipOutputStream.putNextEntry(new ZipEntry(outputKeystore.getName()));
        Files.copy(outputKeystore, zipOutputStream);
      }
      zipOutputStream.putNextEntry(new ZipEntry(outputApk.getName()));
      Files.copy(outputApk, zipOutputStream);
    }
    zipOutputStream.putNextEntry(new ZipEntry("build.out"));
    String buildOutputJson = genBuildOutput(buildResult);
    PrintStream zipPrintStream = new PrintStream(zipOutputStream);
    zipPrintStream.print(buildOutputJson);
    zipPrintStream.flush();

    zipOutputStream.flush();
    zipOutputStream.close();
    if (outputApk != null) {
      outputApk.deleteOnExit();  // Just in case
    }
    if (outputZip != null) {
      outputZip.deleteOnExit();  // Just in case
    }
  }

  private String genBuildOutput(Result buildResult) throws JSONException {
    JSONObject buildOutputJsonObj = new JSONObject();
    buildOutputJsonObj.put("result", buildResult.getResult());
    buildOutputJsonObj.put("error", buildResult.getError());
    buildOutputJsonObj.put("output", buildResult.getOutput());
    if (buildResult.getFormName() != null) {
      buildOutputJsonObj.put("formName", buildResult.getFormName());
    }
    return buildOutputJsonObj.toString();
  }

  private Result build(String userName, File zipFile) throws IOException {
    System.out.println(zipFile.getPath());
    ProjectBuilder projectBuilder = new ProjectBuilder();
    outputDir = Files.createTempDir();
    outputDir.deleteOnExit(); // Just in case
    Result buildResult = projectBuilder.build(userName, new ZipFile(zipFile), outputDir, false,
                                              commandLineOptions.childProcessRamMb);
    String buildOutput = buildResult.getOutput();
    System.out.println("Build output: " + buildOutput);
    String buildError = buildResult.getError();
    System.out.println("Build error output: " + buildError);
    outputApk = projectBuilder.getOutputApk();
    outputKeystore = projectBuilder.getOutputKeystore();
    return buildResult;
  }

  private void cleanUp() {
    if (outputApk != null) {
      outputApk.delete();
    }
    if (outputDir != null) {
      outputDir.delete();
    }
  }

  public static void main(String[] args) throws IOException {
    // TODO(markf): Eventually we'll figure out how to appropriately start and stop the server when
    // it's run in a production environment.   For now, just kill the process
    SelectorThread threadSelector = GrizzlyServerFactory.create("http://localhost:9990/");
    InetAddress localHost = InetAddress.getLocalHost();
    System.out.println("Visit: http://" + localHost.getHostAddress() + ":9990/buildserver");
    System.out.println("Server running");
  }
}
